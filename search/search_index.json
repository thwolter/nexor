{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Nexor documentation","text":"<p>Nexor centralises shared configuration, logging and database helpers that the FDE services rely on. This reference provides both the rationale for adopting the library and direct links into every module's API reference, with the mkdocstrings handler providing live signatures and parameter descriptions.</p>"},{"location":"#purpose-and-scope","title":"Purpose and scope","text":"<ul> <li>Shared configuration: <code>ServiceSettings</code> and the supporting validation helpers keep environment-driven settings consistent from service to service.</li> <li>Database lifecycle: <code>nexor.infrastructure.db</code> exposes cached engines, scoped sessions and connection helpers so each application uses the same asyncpg/SQLAlchemy lifecycle.</li> <li>Cross-cutting observability: Logging and OpenTelemetry initialisation helpers reduce duplication while ensuring consistent resource attributes and exporters.</li> <li>Health and utilities: Lightweight health endpoints plus URL, fingerprint and CORS helpers further smooth integration into FDE services.</li> </ul>"},{"location":"#modules-at-a-glance","title":"Modules at a glance","text":"Module Description api TODO: document the API surface delivered by this module when more context is available. config Application configuration helpers built on <code>ValidatedSettings</code>. health FastAPI health-check routes tied to the shared database utilities. infrastructure Async SQLAlchemy engine/session factories and asyncpg helpers. logging Loguru and stdlib logging initialisation with optional OTLP forwarding. observability OpenTelemetry resource, tracing and metrics bootstrap helpers. utils Reusable validation, fingerprinting and URL-normalisation helpers."},{"location":"#navigating-the-reference","title":"Navigating the reference","text":"<ol> <li>Start with Installation to prep the virtual environment.</li> <li>Follow Quickstart for an end-to-end <code>ServiceSettings</code>/database usage snippet.</li> <li>Dive into each module page for detailed API docs rendered by <code>mkdocstrings</code>.</li> </ol>"},{"location":"#keeping-the-docs-current","title":"Keeping the docs current","text":"<p>Update the <code>::: nexor.&lt;module&gt;</code> sections whenever the exported handlers or settings change so mkdocstrings can regenerate signatures automatically.</p>"},{"location":"installation/","title":"Installation","text":"<p>Provisioning Nexor for local development or production services relies on a <code>uv</code>-managed virtual environment and a standard <code>pip</code> installation of the package.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python version: Nexor requires Python 3.13 or newer as per the project metadata.</li> <li>Tooling: Install uv so that dependency graphs can be reproduced from <code>uv.lock</code>.</li> </ul>"},{"location":"installation/#install-dependencies-with-uv","title":"Install dependencies with uv","text":"<pre><code>uv install\n</code></pre> <ul> <li><code>uv install</code> reads <code>uv.lock</code> and materialises dependencies into <code>.venv</code> (the default uv environment).</li> <li>If you need dev dependencies, run <code>uv install --env dev</code> before installing the package itself.</li> </ul> <p>Activate the generated virtual environment before running <code>pip</code>, e.g.:</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"installation/#install-the-package","title":"Install the package","text":"<p>After the virtual environment is active, install Nexor via <code>pip</code>:</p> <pre><code>pip install -e .\n</code></pre> <p>Alternative consumers can install Nexor as a path dependency:</p> <pre><code>pip install nexor @ file://../nexor\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"Task Command Validate dependency metadata <code>uv lock --check</code> Confirm package imports <code>python -c \"import nexor; print(nexor.__version__ if hasattr(nexor, '__version__') else 'n/a')\"</code> <p>TODO: add platform-specific notes or package mirrors when available.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart demonstrates how to bring together the core Nexor helpers to ship a FastAPI service with consistent configuration, telemetry and health checks.</p>"},{"location":"quickstart/#1-define-service-settings","title":"1. Define service settings","text":"<pre><code>from pydantic import SecretStr\n\nfrom nexor.config import ServiceSettings\n\n\nclass Settings(ServiceSettings):\n    required_keys = ServiceSettings.required_keys + ['redis_url']\n    redis_url: str\n    postgres_url: SecretStr | None = None\n\n\nsettings = Settings()\n</code></pre> <p>This derives from <code>nexor.config.ServiceSettings</code> so the environment validation, normalization and async/sync URLs remain consistent across services. Refer to Configuration for field details.</p>"},{"location":"quickstart/#2-initialise-logging-and-tracing","title":"2. Initialise logging and tracing","text":"<pre><code>from nexor.logging import configure_loguru_logging, LogExporterSettings\nfrom nexor.observability import init_observability\n\nconfigure_loguru_logging(\n    settings=settings,\n    exporter_settings=LogExporterSettings(enabled=True, service_name='my-service'),\n)\n\ninit_observability(service_name='my-service')\n</code></pre> <p>This installs both Loguru and optional OTLP graphing so downstream services ingest a shared trace/resource schema. See logging and observability for the knobs exposed to tune exporters.</p>"},{"location":"quickstart/#3-use-the-shared-database-helpers","title":"3. Use the shared database helpers","text":"<pre><code>from fastapi import FastAPI\n\nfrom nexor.health import install_health_routes\nfrom nexor.infrastructure import db\n\napp = FastAPI()\ninstall_health_routes(app, settings=settings)\n\n\n@app.get('/')\nasync def home():\n    async with db.session_factory(settings=settings) as session:\n        result = await session.execute('SELECT 1')\n        return {'result': result.scalar_one()}\n</code></pre> <p>The <code>db</code> helpers provide cached engines, scoped sessions and asynchronous connection contexts that mirror the lifecycle used across FDE services. <code>install_health_routes</code> wires simple <code>/healthz</code>, <code>/readyz</code> and <code>/readyz/worker</code> endpoints so the service can signal readiness; refer to Health for details.</p>"},{"location":"quickstart/#4-run-the-service","title":"4. Run the service","text":"<pre><code>uv run uvicorn my_service:app --reload\n</code></pre> <p>This assumes an <code>uv</code>-managed environment and lets uvicorn pick up the shared settings. For production deployments, omit <code>--reload</code> and ensure the <code>postgres_url</code>/<code>redis_url</code> are set.</p> <p>TODO: add service-specific extras (e.g. migrations) when more guidance exists.</p>"},{"location":"modules/api/","title":"<code>nexor.api</code>","text":""},{"location":"modules/api/#overview","title":"Overview","text":"<p><code>nexor.api</code> is currently a placeholder module that exists to grow shared API helpers or routers over time. At the moment there are no concrete exports beyond the empty module, but the package exposes this namespace so that future additions can land without breaking consumers.</p> <p>TODO: document concrete helpers once this module gains functionality.</p>"},{"location":"modules/api/#api-reference","title":"API Reference","text":"<pre><code>This module is kept to reserve the namespace for shared API helpers. See [`nexor`](../index.md) for the modules that are currently populated.\n</code></pre>"},{"location":"modules/config/","title":"<code>nexor.config</code>","text":""},{"location":"modules/config/#overview","title":"Overview","text":"<p><code>ServiceSettings</code> is a lightweight base class built on <code>nexor.utils.ValidatedSettings</code>. It centralises the most frequent settings required by FDE services and ensures that critical keys such as <code>postgres_url</code> are present and uniformly normalised.</p> Feature Description Required keys <code>ServiceSettings.required_keys</code> defaults to <code>['postgres_url']</code> and can be extended by subclasses. URL normalisation Both <code>postgres_url</code> and <code>alembic_url</code> are normalised to <code>postgresql://</code> using <code>normalize_postgres_url</code>. Helpers <code>async_postgres_url</code> and <code>migration_url</code> provide driver-swapped versions suitable for asyncpg and Alembic respectively. Metadata <code>env</code>, <code>version</code>, <code>debug</code>, <code>app_schema</code> and pooling knobs are all configurable, keeping the environment signal consistent."},{"location":"modules/config/#example","title":"Example","text":"<pre><code>from pydantic import SecretStr\n\nfrom nexor.config import ServiceSettings\n\n\nclass Settings(ServiceSettings):\n    postgres_url: SecretStr\n    alembic_url: SecretStr\n    debug: bool = True\n\nsettings = Settings()\nprint(settings.async_postgres_url)\n</code></pre> <p>This configuration ensures that your service inherits the standard lifecycle and validation for shared database helpers. See Quickstart for how it ties into the rest of Nexor.</p>"},{"location":"modules/config/#api-reference","title":"API Reference","text":"<p>               Bases: <code>ValidatedSettings</code></p> <p>Lightweight base settings for database-backed services.</p> Source code in <code>src/nexor/config/settings.py</code> <pre><code>class ServiceSettings(ValidatedSettings):\n    \"\"\"Lightweight base settings for database-backed services.\"\"\"\n\n    required_keys = ['postgres_url']\n\n    env: Literal['development', 'production', 'testing'] = 'production'\n    version: str = Field(default_factory=get_app_version)\n    debug: bool | None = None\n    postgres_url: SecretStr | None = None\n    alembic_url: SecretStr | None = None\n    app_schema: str = Field(default_factory=get_app_version)\n    db_pool_size: int = 20\n    db_max_overflow: int = 20\n    db_pool_timeout: int = 30\n\n    @field_validator('postgres_url', mode='before')\n    @classmethod\n    def _normalize_postgres_url(cls, url: str | SecretStr | None) -&gt; SecretStr | None:\n        if url is None:\n            return None\n        if isinstance(url, SecretStr):\n            url = url.get_secret_value()\n        normalized_url = normalize_postgres_url(url)\n        return SecretStr(normalized_url)\n\n    @field_validator('alembic_url', mode='before')\n    @classmethod\n    def _normalize_alembic_url(cls, url: str | SecretStr | None) -&gt; SecretStr | None:\n        if url is None:\n            return None\n        if isinstance(url, SecretStr):\n            url = url.get_secret_value()\n        normalized_url = normalize_postgres_url(url)\n        return SecretStr(normalized_url)\n\n    @property\n    def async_postgres_url(self) -&gt; SecretStr:\n        if self.postgres_url is None:\n            raise RuntimeError('postgres_url must be provided to build async_postgres_url')\n        url = make_url(self.postgres_url.get_secret_value())\n        url = url.set(drivername='postgresql+asyncpg')\n        return SecretStr(url.render_as_string(hide_password=False))\n\n    @property\n    def migration_url(self) -&gt; SecretStr:\n        if self.alembic_url is None:\n            raise RuntimeError('alembic_url must be provided to build migration_url')\n        url = make_url(self.alembic_url.get_secret_value())\n        url = url.set(drivername='postgresql+psycopg')\n        return SecretStr(url.render_as_string(hide_password=False))\n\n    @field_validator('app_schema')\n    @classmethod\n    def _lowercase_schema(cls, value: str) -&gt; str:\n        return value.lower()\n</code></pre>"},{"location":"modules/health/","title":"<code>nexor.health</code>","text":""},{"location":"modules/health/#overview","title":"Overview","text":"<p><code>install_health_routes</code> wires <code>/healthz</code>, <code>/readyz</code> and <code>/readyz/worker</code> endpoints into a FastAPI application, using the shared database helpers to verify connectivity and allowing a custom worker ping callback for background processes.</p> Endpoint Behaviour <code>/healthz</code> Runs <code>nexor.infrastructure.db.test_db_connection</code> to confirm the database is reachable. <code>/readyz</code> Always returns <code>{'status': 'ready'}</code> for generic readiness gating. <code>/readyz/worker</code> Calls the supplied <code>worker_ping</code> and raises a <code>503</code> if it fails."},{"location":"modules/health/#example","title":"Example","text":"<pre><code>from fastapi import FastAPI\n\nfrom myproject.settings import settings\nfrom nexor.health import install_health_routes\n\napp = FastAPI()\ninstall_health_routes(app, settings=settings, prefix='/health', enabled=True)\n</code></pre> <p>Pass <code>worker_ping</code> when background queues or processes have their own health semantics.</p>"},{"location":"modules/health/#api-reference","title":"API Reference","text":"<p>Install health-related routes into the given FastAPI app.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>FastAPI application into which the routes are injected</p> required <code>settings</code> <code>S</code> <p>application settings</p> required <code>prefix</code> <code>str</code> <p>route prefix (customisable by the installing backend)</p> <code>'/health'</code> <code>enabled</code> <code>bool</code> <p>installing backend may disable these routes</p> <code>True</code> <code>worker_ping</code> <code>Callable[[], Awaitable[None]]</code> <p>callable that performs a healthcheck on the worker</p> <code>_noop_worker_ping</code> Source code in <code>src/nexor/health.py</code> <pre><code>def install_health_routes(\n    app: FastAPI,\n    *,\n    settings: S,\n    prefix: str = '/health',\n    enabled: bool = True,\n    worker_ping: Callable[[], Awaitable[None]] = _noop_worker_ping,\n) -&gt; None:\n    \"\"\"\n    Install health-related routes into the given FastAPI app.\n\n    Parameters:\n        app: FastAPI application into which the routes are injected\n        settings: application settings\n        prefix: route prefix (customisable by the installing backend)\n        enabled: installing backend may disable these routes\n        worker_ping: callable that performs a healthcheck on the worker\n    \"\"\"\n    if not enabled:\n        return\n\n    router = APIRouter(prefix=prefix, tags=['health'])\n\n    @router.get('/healthz')\n    async def healthz():  # pragma: no cover - lightweight healthcheck\n        try:\n            await test_db_connection(settings)\n        except Exception as exc:\n            raise HTTPException(status_code=503, detail=str(exc))\n        return {'status': 'ok'}\n\n    @router.get('/readyz')\n    async def readyz():  # pragma: no cover - trivial endpoint\n        return {'status': 'ready'}\n\n    @router.get('/readyz/worker')\n    async def readyz_worker():  # pragma: no cover - lightweight healthcheck\n        try:\n            await worker_ping()\n        except Exception as exc:\n            raise HTTPException(status_code=503, detail=str(exc))\n        return {'status': 'ready'}\n\n    app.include_router(router)\n</code></pre>"},{"location":"modules/infrastructure/","title":"<code>nexor.infrastructure</code>","text":""},{"location":"modules/infrastructure/#overview","title":"Overview","text":"<p>The <code>nexor.infrastructure.db</code> helpers standardise async SQLAlchemy/SQLModel engine creation and session management. They rely on the shared <code>ServiceSettings</code> to normalise <code>postgres_url</code> before switching to <code>postgresql+asyncpg</code>. Caching is keyed by the running event loop plus DSN so concurrent FastAPI workers reuse the same pooled engines.</p> Helper Responsibility <code>get_engine</code> Return or create a cached <code>AsyncEngine</code> for <code>settings.async_postgres_url</code>. <code>session_factory</code> Async context manager yielding a session; handles rollback on exception. <code>scoped_session</code> Wraps <code>tenauth.access_scoped_session_ctx</code> for tenant-aware session scopes. <code>pg_connect</code> / <code>pg_connection</code> Lightweight asyncpg helpers for raw <code>asyncpg.Connection</code>. <code>test_db_connection</code> Attempts repeated connections via <code>dispose_engines</code>/<code>get_engine</code> to validate readiness."},{"location":"modules/infrastructure/#example","title":"Example","text":"<pre><code>from nexor.infrastructure import db\nfrom nexor.config import ServiceSettings\n\n\nasync def fetch_count(settings: ServiceSettings) -&gt; int:\n    async with db.session_factory(settings=settings) as session:\n        result = await session.execute('SELECT count(*) FROM some_table')\n        return result.scalar_one()\n</code></pre> <p>Use <code>db.scoped_session</code> when an <code>AccessContext</code> is available, and rely on <code>test_db_connection</code> inside the <code>/healthz</code> route described in Health.</p>"},{"location":"modules/infrastructure/#api-reference","title":"API Reference","text":""},{"location":"modules/infrastructure/#nexor.infrastructure.db.dispose_engines","title":"dispose_engines  <code>async</code>","text":"<pre><code>dispose_engines(*, loop=None)\n</code></pre> <p>Dispose all database engines associated with a specific event loop.</p> <p>This asynchronous function disposes of all database engine instances that are tied to a particular event loop, freeing up resources. If no event loop is provided, it attempts to retrieve the current default event loop. If the retrieval of the event loop fails, the function exits gracefully.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>Loop | None</code> <p>The specific event loop for which to dispose associated engines. If None, the current event loop is retrieved and used.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/nexor/infrastructure/db.py</code> <pre><code>async def dispose_engines(*, loop: Loop | None = None) -&gt; None:\n    \"\"\"\n    Dispose all database engines associated with a specific event loop.\n\n    This asynchronous function disposes of all database engine instances that\n    are tied to a particular event loop, freeing up resources. If no event loop\n    is provided, it attempts to retrieve the current default event loop. If\n    the retrieval of the event loop fails, the function exits gracefully.\n\n    Args:\n        loop (Loop | None): The specific event loop for which to dispose\n            associated engines. If None, the current event loop is retrieved\n            and used.\n\n    Returns:\n        None\n    \"\"\"\n    if loop is None:\n        try:\n            loop = _current_loop()\n        except RuntimeError:\n            return\n\n    to_dispose = [key for key in _engine_cache if key[0] is loop]\n    for key in to_dispose:\n        engine = _engine_cache.pop(key, None)\n        _sessionmaker_cache.pop(key, None)\n        if engine is not None:\n            await engine.dispose()\n</code></pre>"},{"location":"modules/infrastructure/#nexor.infrastructure.db.get_engine","title":"get_engine","text":"<pre><code>get_engine(settings)\n</code></pre> <p>Creates or retrieves a cached asynchronous database engine.</p> <p>This function generates a new asynchronous engine based on the given service settings or retrieves a cached one if it already exists, using the specified event loop and normalized database URL.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ServiceSettings</code> <p>The configuration settings for the database service, containing parameters required for engine creation such as pool size, timeouts, and debug mode.</p> required <p>Returns:</p> Name Type Description <code>AsyncEngine</code> <code>AsyncEngine</code> <p>An asynchronous database engine instance, either newly created</p> <code>AsyncEngine</code> <p>or fetched from the cache.</p> Source code in <code>src/nexor/infrastructure/db.py</code> <pre><code>def get_engine(settings: ServiceSettings) -&gt; AsyncEngine:\n    \"\"\"\n    Creates or retrieves a cached asynchronous database engine.\n\n    This function generates a new asynchronous engine based on the given service\n    settings or retrieves a cached one if it already exists, using the specified\n    event loop and normalized database URL.\n\n    Args:\n        settings (ServiceSettings): The configuration settings for the database\n            service, containing parameters required for engine creation such as\n            pool size, timeouts, and debug mode.\n\n    Returns:\n        AsyncEngine: An asynchronous database engine instance, either newly created\n        or fetched from the cache.\n    \"\"\"\n    loop = _current_loop()\n    url = _normalize_async_url(settings)\n    key = _cache_key(loop, url)\n    engine = _engine_cache.get(key)\n    if engine is None:\n        engine = create_async_engine(\n            url,\n            echo=settings.debug or False,\n            pool_pre_ping=True,\n            pool_recycle=3600,\n            pool_size=settings.db_pool_size,\n            max_overflow=settings.db_max_overflow,\n            pool_timeout=settings.db_pool_timeout,\n        )\n        _engine_cache[key] = engine\n    return engine\n</code></pre>"},{"location":"modules/infrastructure/#nexor.infrastructure.db.scoped_session","title":"scoped_session  <code>async</code>","text":"<pre><code>scoped_session(*, settings, access_context, verify=True)\n</code></pre> <p>Creates a scoped asynchronous database session context.</p> <p>This function is an asynchronous context manager for managing a scoped asynchronous session tied to a specific service configuration and access context. It ensures that the session is properly committed at the end of successful operations or handled correctly in case of exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ServiceSettings</code> <p>Configuration settings for the service.</p> required <code>access_context</code> <code>AccessContext</code> <p>Contextual information governing access.</p> required <code>verify</code> <code>bool</code> <p>Flag to indicate whether session verification should be performed. Defaults to True.</p> <code>True</code> <p>Yields:</p> Name Type Description <code>AsyncSession</code> <code>AsyncIterator[AsyncSession]</code> <p>An asynchronous session object to interact with the</p> <code>AsyncIterator[AsyncSession]</code> <p>database.</p> Source code in <code>src/nexor/infrastructure/db.py</code> <pre><code>@asynccontextmanager\nasync def scoped_session(\n    *,\n    settings: ServiceSettings,\n    access_context: AccessContext,\n    verify: bool = True,\n) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"\n    Creates a scoped asynchronous database session context.\n\n    This function is an asynchronous context manager for managing a scoped\n    asynchronous session tied to a specific service configuration and access\n    context. It ensures that the session is properly committed at the end\n    of successful operations or handled correctly in case of exceptions.\n\n    Args:\n        settings (ServiceSettings): Configuration settings for the service.\n        access_context (AccessContext): Contextual information governing access.\n        verify (bool): Flag to indicate whether session verification should\n            be performed. Defaults to True.\n\n    Yields:\n        AsyncSession: An asynchronous session object to interact with the\n        database.\n    \"\"\"\n    async with access_scoped_session_ctx(\n        session_factory=lambda: session_factory(settings),\n        access_context=access_context,\n        verify=verify,\n    ) as session:\n        exc: Exception | None = None\n        try:\n            yield session\n        except Exception as err:\n            exc = err\n            raise\n        finally:\n            if exc is None:\n                await session.commit()\n</code></pre>"},{"location":"modules/infrastructure/#nexor.infrastructure.db.session_factory","title":"session_factory  <code>async</code>","text":"<pre><code>session_factory(settings)\n</code></pre> <p>Creates an asynchronous context manager for managing database sessions.</p> <p>This function serves as a factory for generating asynchronous sessions for database operations. It yields an active session, handles rollback in case of exceptions, and ensures the session is closed after operations are completed.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ServiceSettings</code> <p>ServiceSettings instance containing the configuration for creating the sessionmaker.</p> required <p>Yields:</p> Name Type Description <code>AsyncSession</code> <code>AsyncIterator[AsyncSession]</code> <p>An active asynchronous session object for interacting with the database.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Propagates any encountered exception after ensuring the session is rolled back.</p> Source code in <code>src/nexor/infrastructure/db.py</code> <pre><code>@asynccontextmanager\nasync def session_factory(settings: ServiceSettings) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"Creates an asynchronous context manager for managing database sessions.\n\n    This function serves as a factory for generating asynchronous sessions for database\n    operations. It yields an active session, handles rollback in case of exceptions, and\n    ensures the session is closed after operations are completed.\n\n    Args:\n        settings: ServiceSettings instance containing the configuration for creating the\n            sessionmaker.\n\n    Yields:\n        AsyncSession: An active asynchronous session object for interacting with the database.\n\n    Raises:\n        Exception: Propagates any encountered exception after ensuring the session is\n            rolled back.\n    \"\"\"\n    session = _get_sessionmaker(settings)()\n    try:\n        yield session\n    except Exception:\n        await session.rollback()\n        raise\n    finally:\n        await session.close()\n</code></pre>"},{"location":"modules/infrastructure/#nexor.infrastructure.db.test_db_connection","title":"test_db_connection  <code>async</code>","text":"<pre><code>test_db_connection(settings)\n</code></pre> <p>Tests the database connection using the provided settings.</p> <p>This function attempts to establish a database connection and logs the result. If the connection fails, it disposes of the database engines and raises a RuntimeError. It's intended to ensure the database service settings are correct and functional.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>ServiceSettings</code> <p>The service settings required for establishing the database connection.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the database connection could not be established.</p> Source code in <code>src/nexor/infrastructure/db.py</code> <pre><code>async def test_db_connection(settings: ServiceSettings) -&gt; None:\n    \"\"\"\n    Tests the database connection using the provided settings.\n\n    This function attempts to establish a database connection and logs the result.\n    If the connection fails, it disposes of the database engines and raises a\n    RuntimeError. It's intended to ensure the database service settings are\n    correct and functional.\n\n    Args:\n        settings: The service settings required for establishing the database\n            connection.\n\n    Raises:\n        RuntimeError: If the database connection could not be established.\n    \"\"\"\n    try:\n        await _test_db_connection_once(settings)\n        logger.info('Database connection test successful')\n    except Exception as exc:\n        logger.exception('Database connection test failed')\n        await dispose_engines()\n        raise RuntimeError('Failed to connect to database') from exc\n</code></pre>"},{"location":"modules/logging/","title":"<code>nexor.logging</code>","text":""},{"location":"modules/logging/#overview","title":"Overview","text":"<p>Logging helpers configure both Loguru and the standard library logger to share defaults across FDE services. They also wire optional OTLP forwarding that reuses the resource construction logic from <code>nexor.observability</code>.</p> Function Purpose <code>configure_loguru_logging</code> Sets up Loguru sinks, optionally bridges to stdlib, and enables OTLP forwarding when requested. <code>configure_std_logging</code> Applies <code>logging.basicConfig</code>, respects user-defined formatter/level, then optionally wires OTLP. <code>LogExporterSettings</code> Captures OTLP configuration (endpoint, headers, service namespace) and resource overrides."},{"location":"modules/logging/#example","title":"Example","text":"<pre><code>from nexor.logging import configure_loguru_logging, LogExporterSettings\n\nconfigure_loguru_logging(\n    settings=settings,\n    exporter_settings=LogExporterSettings(\n        enabled=True,\n        endpoint='https://otel-collector.example',\n        headers='api-key=secret',\n        service_name='my-service',\n    ),\n)\n</code></pre> <p>When OTLP is enabled, both OpenTelemetry SDK logging and <code>logger.add</code> share the same resource. The helper also ensures the log level is kept in sync via <code>_map_loguru_level</code>. For stdlib-only instrumentation, call <code>configure_std_logging</code> directly and share the <code>LogExporterSettings</code>.</p>"},{"location":"modules/logging/#backend-initialization","title":"Backend initialization","text":"<p>Services that implement application-specific backends should call <code>configure_loguru_logging</code> early so every component inherits the same sinks, OTLP exporter, and resource metadata. The <code>LogExporterSettings</code> instance can be reused by other helpers, keeping exporter configuration centralized:</p> <pre><code>from nexor.logging import configure_loguru_logging, LogExporterSettings\nfrom loguru import logger\n\n\ndef bootstrap_backend(settings) -&gt; None:\n    exporter_settings = LogExporterSettings(\n        enabled=True,\n        endpoint='https://otel-collector.example',\n        headers='api-key=secret',\n        service_name=settings.service_name,\n        resource_attributes={'service.namespace': 'backend'},\n    )\n\n    configure_loguru_logging(settings=settings, exporter_settings=exporter_settings)\n    logger.info('Backend ready, logs routed to Loguru sinks and OTLP')\n</code></pre> <p>Any background worker or HTTP handler can now call <code>logger.bind(component='worker')</code> to tag its entries, and the same <code>exporter_settings</code> can be passed to <code>configure_std_logging</code> if standard library loggers need the identical OTLP pipeline.</p>"},{"location":"modules/logging/#api-reference","title":"API Reference","text":""},{"location":"modules/logging/#nexor.logging.configure_loguru_logging","title":"configure_loguru_logging","text":"<pre><code>configure_loguru_logging(\n    *, settings, exporter_settings=None\n)\n</code></pre> <p>Configures the Loguru logger with the specified settings and optional exporter settings.</p> <p>This function adjusts the Loguru logging configuration based on parameters found in the provided <code>settings</code> object. If exporter settings are provided and their use is enabled, additional configuration is applied to support OTLP logging. The function ensures that the Loguru logger is only configured once during the runtime.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>object</code> <p>An object containing various log configuration options such as log level, whether to use default sinks, and serialization preferences.</p> required <code>exporter_settings</code> <code>LogExporterSettings | None</code> <p>Optional settings to enable and configure OTLP logging. If not provided or disabled, no additional OTLP configuration is applied.</p> <code>None</code> Source code in <code>src/nexor/logging.py</code> <pre><code>def configure_loguru_logging(\n    *,\n    settings: object,\n    exporter_settings: LogExporterSettings | None = None,\n) -&gt; None:\n    \"\"\"\n    Configures the Loguru logger with the specified settings and optional exporter settings.\n\n    This function adjusts the Loguru logging configuration based on parameters found in\n    the provided `settings` object. If exporter settings are provided and their use\n    is enabled, additional configuration is applied to support OTLP logging. The function\n    ensures that the Loguru logger is only configured once during the runtime.\n\n    Args:\n        settings (object): An object containing various log configuration options such as\n            log level, whether to use default sinks, and serialization preferences.\n        exporter_settings (LogExporterSettings | None): Optional settings to enable\n            and configure OTLP logging. If not provided or disabled, no additional\n            OTLP configuration is applied.\n    \"\"\"\n    global _configured_loguru\n    if _configured_loguru:\n        return\n\n    if getattr(settings, 'log_remove_default_sink', True):\n        logger.remove()\n\n    logger.add(\n        sys.stderr,\n        level=getattr(settings, 'log_level', 'INFO'),\n        enqueue=getattr(settings, 'log_enqueue', True),\n        backtrace=getattr(settings, 'log_backtrace', True),\n        diagnose=getattr(settings, 'log_diagnose', False),\n        serialize=not getattr(settings, 'log_console_plain', True),\n        format='&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | '\n        '&lt;level&gt;{level: &lt;8}&lt;/level&gt; | '\n        '&lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - '\n        '&lt;level&gt;{message}&lt;/level&gt;',\n    )\n\n    if exporter_settings and exporter_settings.enabled:\n        _configure_otlp_loguru(settings=settings, exporter_settings=exporter_settings)\n\n    _configured_loguru = True\n</code></pre>"},{"location":"modules/logging/#nexor.logging.configure_std_logging","title":"configure_std_logging","text":"<pre><code>configure_std_logging(\n    *,\n    settings,\n    formatter='%(asctime)s %(levelname)s [%(name)s] %(message)s',\n    exporter_settings=None,\n)\n</code></pre> <p>Configures standard library logging with possible customization for log format, log level, and additional exporter settings.</p> <p>Standard logging configuration is applied globally only once. Further attempts to execute this function will not reconfigure the logging.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>object</code> <p>An object containing the logging configuration. The 'log_level' attribute determines the log level. If not provided, defaults to 'INFO'.</p> required <code>formatter</code> <code>str</code> <p>Format string for log messages. Defaults to '%(asctime)s %(levelname)s [%(name)s] %(message)s'.</p> <code>'%(asctime)s %(levelname)s [%(name)s] %(message)s'</code> <code>exporter_settings</code> <code>LogExporterSettings | None</code> <p>Optional settings for an external log exporter. If <code>exporter_settings.enabled</code> is set to True, additional configuration for exporting logs is applied.</p> <code>None</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If 'settings' is missing required 'log_level' attribute or if specified log level is invalid.</p> Source code in <code>src/nexor/logging.py</code> <pre><code>def configure_std_logging(\n    *,\n    settings: object,\n    formatter: str = '%(asctime)s %(levelname)s [%(name)s] %(message)s',\n    exporter_settings: LogExporterSettings | None = None,\n) -&gt; None:\n    \"\"\"\n    Configures standard library logging with possible customization for log format,\n    log level, and additional exporter settings.\n\n    Standard logging configuration is applied globally only once. Further attempts to\n    execute this function will not reconfigure the logging.\n\n    Args:\n        settings (object): An object containing the logging configuration. The\n            'log_level' attribute determines the log level. If not provided,\n            defaults to 'INFO'.\n        formatter (str): Format string for log messages. Defaults to\n            '%(asctime)s %(levelname)s [%(name)s] %(message)s'.\n        exporter_settings (LogExporterSettings | None): Optional settings for an\n            external log exporter. If `exporter_settings.enabled` is set to True,\n            additional configuration for exporting logs is applied.\n\n    Raises:\n        AttributeError: If 'settings' is missing required 'log_level' attribute\n            or if specified log level is invalid.\n    \"\"\"\n    global _configured_stdlib\n    if _configured_stdlib:\n        return\n\n    root_logger = logging.getLogger()\n\n    level_name = getattr(settings, 'log_level', 'INFO')\n    level = getattr(logging, level_name.upper(), logging.INFO)\n\n    if not root_logger.handlers:\n        logging.basicConfig(level=level, format=formatter)\n    root_logger.setLevel(level)\n\n    if exporter_settings and exporter_settings.enabled:\n        _configure_otlp_stdlib(\n            exporter_settings=exporter_settings,\n            level=level,\n            root_logger=root_logger,\n            settings=settings,\n        )\n\n    _configured_stdlib = True\n</code></pre>"},{"location":"modules/observability/","title":"<code>nexor.observability</code>","text":""},{"location":"modules/observability/#overview","title":"Overview","text":"<p>Observability helpers centralise the OpenTelemetry configuration that FDE services otherwise repeat. They build a <code>Resource</code> with service metadata, initialise tracing and metrics providers, and optionally instrument FastAPI or worker processes.</p> Helper Description <code>build_resource</code> Constructs a <code>Resource</code> using <code>service.name</code>, <code>deployment.environment</code>, and optional extras. <code>parse_otlp_headers</code> Parses comma-separated <code>key=value</code> pairs into a header dictionary for OTLP exporters. <code>init_observability</code> Bootstraps <code>TracerProvider</code> and <code>MeterProvider</code> with OTLP span/metric processors. <code>init_otel_fastapi</code> Adds FastAPI instrumentation via <code>FastAPIInstrumentor</code> after ensuring providers exist. <code>init_otel_worker</code> Initialises global providers for background worker processes. <code>get_tracer</code> Convenience wrapper for <code>trace.get_tracer</code>."},{"location":"modules/observability/#example","title":"Example","text":"<pre><code>from nexor.observability import init_observability, init_otel_fastapi\n\nresource_kwargs = {\n    'service_name': 'my-service',\n    'deployment_environment': 'production',\n}\ninit_observability(**resource_kwargs)\ninit_otel_fastapi(app, **resource_kwargs)\n</code></pre> <p>If <code>FastAPIInstrumentor</code> is unavailable, <code>init_otel_fastapi</code> falls back gracefully, but the shared providers are still initialised. Pass <code>extra</code> to add service-specific resource attributes.</p>"},{"location":"modules/observability/#api-reference","title":"API Reference","text":""},{"location":"modules/observability/#nexor.observability.build_resource","title":"build_resource","text":"<pre><code>build_resource(\n    *,\n    service_name,\n    service_namespace=None,\n    deployment_environment=None,\n    extra=None,\n)\n</code></pre> <p>Builds a resource object by utilizing provided service details and additional metadata. This function is a wrapper around <code>_build_resource</code> to streamline the creation of the resource object.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>The name of the service for which the resource is being built.</p> required <code>service_namespace</code> <code>Optional[str]</code> <p>An optional namespace for the service, typically representing the group or organization the service belongs to.</p> <code>None</code> <code>deployment_environment</code> <code>Optional[str]</code> <p>An optional deployment environment name, such as \"production\", \"staging\", or \"development\".</p> <code>None</code> <code>extra</code> <code>Optional[Mapping[str, str]]</code> <p>Optional additional metadata provided as key-value pairs for the resource.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Resource</code> <code>Resource</code> <p>The constructed resource object.</p> Source code in <code>src/nexor/observability.py</code> <pre><code>def build_resource(\n    *,\n    service_name: str,\n    service_namespace: Optional[str] = None,\n    deployment_environment: Optional[str] = None,\n    extra: Optional[Mapping[str, str]] = None,\n) -&gt; Resource:\n    \"\"\"\n    Builds a resource object by utilizing provided service details and additional\n    metadata. This function is a wrapper around `_build_resource` to streamline\n    the creation of the resource object.\n\n    Args:\n        service_name (str): The name of the service for which the resource is\n            being built.\n        service_namespace (Optional[str]): An optional namespace for the service,\n            typically representing the group or organization the service belongs to.\n        deployment_environment (Optional[str]): An optional deployment environment\n            name, such as \"production\", \"staging\", or \"development\".\n        extra (Optional[Mapping[str, str]]): Optional additional metadata provided\n            as key-value pairs for the resource.\n\n    Returns:\n        Resource: The constructed resource object.\n    \"\"\"\n    return _build_resource(\n        service_name=service_name,\n        service_namespace=service_namespace,\n        deployment_environment=deployment_environment,\n        extra=extra,\n    )\n</code></pre>"},{"location":"modules/observability/#nexor.observability.get_tracer","title":"get_tracer","text":"<pre><code>get_tracer(name)\n</code></pre> <p>Retrieves a tracer by its specified name. Tracers are used for capturing telemetry data such as spans, events, and context for distributed tracing.</p> <p>This function enables interaction with the tracing framework, allowing developers to track operation flows and measure performance characteristics of their systems.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tracer to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Tracer</code> <p>An instance of the requested tracer.</p> Source code in <code>src/nexor/observability.py</code> <pre><code>def get_tracer(name: str):\n    \"\"\"\n    Retrieves a tracer by its specified name. Tracers are used for capturing\n    telemetry data such as spans, events, and context for distributed tracing.\n\n    This function enables interaction with the tracing framework, allowing\n    developers to track operation flows and measure performance characteristics\n    of their systems.\n\n    Args:\n        name (str): The name of the tracer to retrieve.\n\n    Returns:\n        Tracer: An instance of the requested tracer.\n    \"\"\"\n    return trace.get_tracer(name)\n</code></pre>"},{"location":"modules/observability/#nexor.observability.init_observability","title":"init_observability","text":"<pre><code>init_observability(\n    *,\n    service_name,\n    service_namespace=None,\n    deployment_environment=None,\n    extra=None,\n)\n</code></pre> <p>Initializes observability resources required for monitoring and reporting.</p> <p>This function creates and configures the necessary resources to enable observability for a given service. It helps ensure that required providers for tracing and metrics are properly set up.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>The name of the service to be monitored.</p> required <code>service_namespace</code> <code>Optional[str]</code> <p>The namespace of the service, used for categorization and grouping of related services. Defaults to None.</p> <code>None</code> <code>deployment_environment</code> <code>Optional[str]</code> <p>The environment in which the service is deployed, such as \"production\" or \"staging\". Defaults to None.</p> <code>None</code> <code>extra</code> <code>Optional[Mapping[str, str]]</code> <p>Additional metadata or key-value pairs to enrich the observability resource. Defaults to None.</p> <code>None</code> Source code in <code>src/nexor/observability.py</code> <pre><code>def init_observability(\n    *,\n    service_name: str,\n    service_namespace: Optional[str] = None,\n    deployment_environment: Optional[str] = None,\n    extra: Optional[Mapping[str, str]] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes observability resources required for monitoring and reporting.\n\n    This function creates and configures the necessary resources to enable observability\n    for a given service. It helps ensure that required providers for tracing and metrics\n    are properly set up.\n\n    Args:\n        service_name: The name of the service to be monitored.\n        service_namespace: The namespace of the service, used for categorization and\n            grouping of related services. Defaults to None.\n        deployment_environment: The environment in which the service is deployed, such\n            as \"production\" or \"staging\". Defaults to None.\n        extra: Additional metadata or key-value pairs to enrich the observability\n            resource. Defaults to None.\n    \"\"\"\n    resource = build_resource(\n        service_name=service_name,\n        service_namespace=service_namespace,\n        deployment_environment=deployment_environment,\n        extra=extra,\n    )\n    _ensure_provider(resource)\n    _ensure_metrics_provider(resource)\n</code></pre>"},{"location":"modules/observability/#nexor.observability.init_otel_fastapi","title":"init_otel_fastapi","text":"<pre><code>init_otel_fastapi(\n    app,\n    *,\n    service_name,\n    service_namespace=None,\n    deployment_environment=None,\n    extra=None,\n)\n</code></pre> <p>Initializes OpenTelemetry observability for a FastAPI application.</p> <p>This function configures OpenTelemetry instrumentation for the provided FastAPI instance. It initializes the service observability with the given service name, optional service namespace, deployment environment, and additional attributes. If the FastAPIInstrumentor is available, the function ensures that the app is instrumented by uninstrumenting any existing instrumentation first and then reapplying it.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <p>The FastAPI application instance to be instrumented.</p> required <code>service_name</code> <code>str</code> <p>The name of the service, utilized for observability.</p> required <code>service_namespace</code> <code>Optional[str]</code> <p>The namespace of the service, useful for logical grouping. Defaults to None.</p> <code>None</code> <code>deployment_environment</code> <code>Optional[str]</code> <p>The environment in which the service is deployed (e.g., production, staging). Defaults to None.</p> <code>None</code> <code>extra</code> <code>Optional[Mapping[str, str]]</code> <p>A mapping of additional attributes to supplement observability data. Defaults to None.</p> <code>None</code> Source code in <code>src/nexor/observability.py</code> <pre><code>def init_otel_fastapi(\n    app,\n    *,\n    service_name: str,\n    service_namespace: Optional[str] = None,\n    deployment_environment: Optional[str] = None,\n    extra: Optional[Mapping[str, str]] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes OpenTelemetry observability for a FastAPI application.\n\n    This function configures OpenTelemetry instrumentation for the provided FastAPI\n    instance. It initializes the service observability with the given service name,\n    optional service namespace, deployment environment, and additional attributes.\n    If the FastAPIInstrumentor is available, the function ensures that the app is\n    instrumented by uninstrumenting any existing instrumentation first and then\n    reapplying it.\n\n    Args:\n        app: The FastAPI application instance to be instrumented.\n        service_name: The name of the service, utilized for observability.\n        service_namespace: The namespace of the service, useful for logical grouping.\n            Defaults to None.\n        deployment_environment: The environment in which the service is deployed\n            (e.g., production, staging). Defaults to None.\n        extra: A mapping of additional attributes to supplement observability\n            data. Defaults to None.\n    \"\"\"\n    init_observability(\n        service_name=service_name,\n        service_namespace=service_namespace,\n        deployment_environment=deployment_environment,\n        extra=extra,\n    )\n\n    if FastAPIInstrumentor is not None:\n        try:\n            if hasattr(FastAPIInstrumentor, 'uninstrument_app'):\n                FastAPIInstrumentor.uninstrument_app(app)  # type: ignore[attr-defined]\n        except Exception:\n            pass\n        if hasattr(FastAPIInstrumentor, 'instrument_app'):\n            FastAPIInstrumentor.instrument_app(app)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"modules/observability/#nexor.observability.init_otel_worker","title":"init_otel_worker","text":"<pre><code>init_otel_worker(\n    *,\n    service_name,\n    service_namespace=None,\n    deployment_environment=None,\n    extra=None,\n)\n</code></pre> <p>Initializes OpenTelemetry worker for setting up observability features.</p> <p>This function provides an interface for initializing observability capabilities using OpenTelemetry by configuring telemetry data with specified service details and environmental context. It ensures that service-related metrics, traces, or logs can be collected appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>The unique name of the service for which observability is being set up.</p> required <code>service_namespace</code> <code>Optional[str]</code> <p>The namespace in which the service resides, typically used for organizing services in larger environments. Defaults to None.</p> <code>None</code> <code>deployment_environment</code> <code>Optional[str]</code> <p>Specifies the environment where the deployment occurs (e.g., 'production', 'staging'). Defaults to None.</p> <code>None</code> <code>extra</code> <code>Optional[Mapping[str, str]]</code> <p>Additional metadata or parameters to be attached to the telemetry data. Defaults to None.</p> <code>None</code> Source code in <code>src/nexor/observability.py</code> <pre><code>def init_otel_worker(\n    *,\n    service_name: str,\n    service_namespace: Optional[str] = None,\n    deployment_environment: Optional[str] = None,\n    extra: Optional[Mapping[str, str]] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes OpenTelemetry worker for setting up observability features.\n\n    This function provides an interface for initializing observability\n    capabilities using OpenTelemetry by configuring telemetry data\n    with specified service details and environmental context. It ensures\n    that service-related metrics, traces, or logs can be collected\n    appropriately.\n\n    Args:\n        service_name (str): The unique name of the service for which\n            observability is being set up.\n        service_namespace (Optional[str]): The namespace in which the\n            service resides, typically used for organizing services in larger\n            environments. Defaults to None.\n        deployment_environment (Optional[str]): Specifies the environment\n            where the deployment occurs (e.g., 'production', 'staging').\n            Defaults to None.\n        extra (Optional[Mapping[str, str]]): Additional metadata or parameters\n            to be attached to the telemetry data. Defaults to None.\n    \"\"\"\n    init_observability(\n        service_name=service_name,\n        service_namespace=service_namespace,\n        deployment_environment=deployment_environment,\n        extra=extra,\n    )\n</code></pre>"},{"location":"modules/observability/#nexor.observability.parse_otlp_headers","title":"parse_otlp_headers","text":"<pre><code>parse_otlp_headers(raw_headers)\n</code></pre> <p>Parses a string of headers into a dictionary format.</p> <p>This function takes a string of comma-separated key-value pairs representing headers and parses them into a dictionary. Each key-value pair should be separated by an equals sign (<code>=</code>). If the input is <code>None</code> or improperly formatted, an empty dictionary is returned.</p> <p>Parameters:</p> Name Type Description Default <code>raw_headers</code> <code>str | None</code> <p>A string of comma-separated key-value pairs representing headers, where each pair is in the format <code>key=value</code>. Can also be <code>None</code>.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>A dictionary where the keys are the header names and the values are the</p> <code>Dict[str, str]</code> <p>corresponding header values. If <code>raw_headers</code> is <code>None</code> or improperly</p> <code>Dict[str, str]</code> <p>formatted, returns an empty dictionary.</p> Source code in <code>src/nexor/observability.py</code> <pre><code>def parse_otlp_headers(raw_headers: str | None) -&gt; Dict[str, str]:\n    \"\"\"\n    Parses a string of headers into a dictionary format.\n\n    This function takes a string of comma-separated key-value pairs representing\n    headers and parses them into a dictionary. Each key-value pair should be\n    separated by an equals sign (`=`). If the input is `None` or improperly\n    formatted, an empty dictionary is returned.\n\n    Args:\n        raw_headers: A string of comma-separated key-value pairs representing\n            headers, where each pair is in the format `key=value`. Can also be\n            `None`.\n\n    Returns:\n        A dictionary where the keys are the header names and the values are the\n        corresponding header values. If `raw_headers` is `None` or improperly\n        formatted, returns an empty dictionary.\n    \"\"\"\n    if not raw_headers:\n        return {}\n    headers: Dict[str, str] = {}\n    for pair in raw_headers.split(','):\n        item = pair.strip()\n        if not item or '=' not in item:\n            continue\n        key, value = item.split('=', 1)\n        headers[key.strip()] = value.strip()\n    return headers\n</code></pre>"},{"location":"modules/utils/","title":"<code>nexor.utils</code>","text":""},{"location":"modules/utils/#overview","title":"Overview","text":"<p>Utility helpers underpin the configuration validation and fingerprinting behaviour used across the package. They also allow services to derive metadata such as the package name or version without repeating TOML parsing logic.</p> Helper Description <code>parse_cors_origins</code> Normalises environment-specified CORS origins supplied as JSON, CSV or single strings. <code>ValidatedSettings</code> BaseSettings subclass that enforces <code>required_keys</code> via <code>_check_missing_keys</code>. <code>ValidatedModel</code> BaseModel counterpart that issues warnings rather than raising when required fields are absent. <code>FingerprintMixin</code> Adds deterministic fingerprinting to Pydantic models using selected include/exclude sets. <code>normalize_postgres_url</code> Converts <code>postgres://</code> URLs to <code>postgresql://</code>. <code>get_app_name</code>, <code>get_app_version</code> Read the <code>project.name</code>/<code>project.version</code> values from the nearest <code>pyproject.toml</code>."},{"location":"modules/utils/#example","title":"Example","text":"<pre><code>from nexor.utils import FingerprintMixin\n\n\nclass RequestBody(FingerprintMixin):\n    fingerprint_keys = ['user_id', 'payload']\n\n    user_id: int\n    payload: dict\n\n\nrequest = RequestBody(user_id=42, payload={'foo': 'bar'})\nprint(request.get_fingerprint())\n</code></pre> <p>The fingerprint helper ensures deterministic hashes even when dictionary keys reorder, thanks to JSON dumping with sorted keys.</p>"},{"location":"modules/utils/#api-reference","title":"API Reference","text":""},{"location":"modules/utils/#nexor.utils.FingerprintMixin","title":"FingerprintMixin","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mixin class for generating unique fingerprints for model instances.</p> <p>This class provides functionality to calculate a cryptographic fingerprint based on the specified fields of the model. It verifies that included and excluded fields are valid and do not have conflicts. The resulting fingerprint ensures uniqueness based on the specified attributes.</p> <p>Attributes:</p> Name Type Description <code>fingerprint_keys</code> <code>ClassVar[Sequence[str] | None]</code> <p>Specifies the fields to be included in the fingerprint calculation. If None, all fields are considered.</p> <code>fingerprint_exclude</code> <code>ClassVar[Sequence[str] | None]</code> <p>Specifies the fields to be excluded from the fingerprint calculation.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>class FingerprintMixin(BaseModel):\n    \"\"\"\n    A mixin class for generating unique fingerprints for model instances.\n\n    This class provides functionality to calculate a cryptographic fingerprint\n    based on the specified fields of the model. It verifies that included and\n    excluded fields are valid and do not have conflicts. The resulting fingerprint\n    ensures uniqueness based on the specified attributes.\n\n    Attributes:\n        fingerprint_keys (ClassVar[Sequence[str] | None]): Specifies the fields to be\n            included in the fingerprint calculation. If None, all fields are considered.\n        fingerprint_exclude (ClassVar[Sequence[str] | None]): Specifies the fields to\n            be excluded from the fingerprint calculation.\n    \"\"\"\n\n    fingerprint_keys: ClassVar[Sequence[str] | None] = None\n    fingerprint_exclude: ClassVar[Sequence[str] | None] = None\n\n    def get_fingerprint(self) -&gt; str:\n        include_set = set(self.fingerprint_keys) if self.fingerprint_keys is not None else None\n        exclude_set = set(self.fingerprint_exclude) if self.fingerprint_exclude is not None else None\n\n        if include_set and exclude_set:\n            overlap = include_set &amp; exclude_set\n            if overlap:\n                joined = ', '.join(sorted(overlap))\n                raise ValueError(f'Fingerprint keys appear in both include and exclude: {joined}')\n\n        model_fields = set(type(self).model_fields)\n        if include_set is not None:\n            invalid_includes = include_set - model_fields\n            if invalid_includes:\n                joined = ', '.join(sorted(invalid_includes))\n                raise ValueError(f'Fingerprint include references unknown fields: {joined}')\n\n        if exclude_set is not None:\n            invalid_excludes = exclude_set - model_fields\n            if invalid_excludes:\n                joined = ', '.join(sorted(invalid_excludes))\n                raise ValueError(f'Fingerprint exclude references unknown fields: {joined}')\n\n        payload = self.model_dump(include=include_set, exclude=exclude_set, mode='json')\n        canonical = json.dumps(payload, sort_keys=True, separators=(',', ':'))\n        return hashlib.sha256(canonical.encode()).hexdigest()\n</code></pre>"},{"location":"modules/utils/#nexor.utils.ValidatedModel","title":"ValidatedModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a validated model with required keys.</p> <p>This class is a subclass of BaseModel. It is designed to provide functionality to ensure that certain required keys are present in its data. It supports customizable behavior through its attributes.</p> <p>Attributes:</p> Name Type Description <code>required_keys</code> <code>ClassVar[list[str]]</code> <p>A class-level attribute representing a list of keys that are required for the model.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>class ValidatedModel(BaseModel):\n    \"\"\"\n    Represents a validated model with required keys.\n\n    This class is a subclass of BaseModel. It is designed to provide\n    functionality to ensure that certain required keys are present in its\n    data. It supports customizable behavior through its attributes.\n\n    Attributes:\n        required_keys (ClassVar[list[str]]): A class-level attribute\n            representing a list of keys that are required for the model.\n    \"\"\"\n\n    required_keys: ClassVar[list[str]] = []\n\n    def model_post_init(self, context: Any, /) -&gt; None:\n        _check_missing_keys(self, raise_on_missing=False)\n</code></pre>"},{"location":"modules/utils/#nexor.utils.ValidatedSettings","title":"ValidatedSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>ValidatedSettings is a subclass of BaseSettings designed to ensure critical configuration settings are present during initialization.</p> <p>This class provides a mechanism to validate the presence of required configuration keys, helping to prevent runtime errors due to missing settings. After the instance is created, it automatically checks for missing keys based on the defined <code>required_keys</code> class variable.</p> <p>Attributes:</p> Name Type Description <code>required_keys</code> <code>ClassVar[list[str]]</code> <p>A class-level attribute that lists the keys required to be present during validation.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>class ValidatedSettings(BaseSettings):\n    \"\"\"\n    ValidatedSettings is a subclass of BaseSettings designed to ensure critical configuration\n    settings are present during initialization.\n\n    This class provides a mechanism to validate the presence of required configuration keys,\n    helping to prevent runtime errors due to missing settings. After the instance is created,\n    it automatically checks for missing keys based on the defined `required_keys` class variable.\n\n    Attributes:\n        required_keys (ClassVar[list[str]]): A class-level attribute that lists the keys\n            required to be present during validation.\n    \"\"\"\n\n    required_keys: ClassVar[list[str]] = []\n\n    def model_post_init(self, context: Any, /) -&gt; None:\n        _check_missing_keys(self)\n</code></pre>"},{"location":"modules/utils/#nexor.utils.get_app_name","title":"get_app_name","text":"<pre><code>get_app_name()\n</code></pre> <p>Retrieves the application name from the project's metadata.</p> <p>The function utilizes the project's metadata to fetch the name of the application.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the application.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>def get_app_name() -&gt; str:\n    \"\"\"\n    Retrieves the application name from the project's metadata.\n\n    The function utilizes the project's metadata to fetch\n    the name of the application.\n\n    Returns:\n        str: The name of the application.\n    \"\"\"\n    return _load_project_metadata('name')\n</code></pre>"},{"location":"modules/utils/#nexor.utils.get_app_version","title":"get_app_version","text":"<pre><code>get_app_version()\n</code></pre> <p>Retrieves the current application version.</p> <p>This function fetches the version information of the application from the project's metadata.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The current version of the application.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>def get_app_version() -&gt; str:\n    \"\"\"\n    Retrieves the current application version.\n\n    This function fetches the version information of the application\n    from the project's metadata.\n\n    Returns:\n        str: The current version of the application.\n    \"\"\"\n    return _load_project_metadata('version')\n</code></pre>"},{"location":"modules/utils/#nexor.utils.normalize_postgres_url","title":"normalize_postgres_url","text":"<pre><code>normalize_postgres_url(url)\n</code></pre> <p>Normalizes a PostgreSQL connection URL to use the 'postgresql://' schema instead of the deprecated 'postgres://' schema.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The PostgreSQL connection URL to be normalized.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A normalized PostgreSQL connection URL starting with 'postgresql://'.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>def normalize_postgres_url(url: str) -&gt; str:\n    \"\"\"\n    Normalizes a PostgreSQL connection URL to use the 'postgresql://' schema instead\n    of the deprecated 'postgres://' schema.\n\n    Args:\n        url (str): The PostgreSQL connection URL to be normalized.\n\n    Returns:\n        str: A normalized PostgreSQL connection URL starting with 'postgresql://'.\n    \"\"\"\n    if url.startswith('postgres://'):\n        return url.replace('postgres://', 'postgresql://', 1)\n    return url\n</code></pre>"},{"location":"modules/utils/#nexor.utils.parse_cors_origins","title":"parse_cors_origins","text":"<pre><code>parse_cors_origins(value)\n</code></pre> <p>Parses and normalizes CORS origins from a string, list, or None into a tuple of strings.</p> <p>This function handles various input formats to ensure they are correctly parsed into a standardized tuple of origin strings usable for configuration. The input can be a string, list of strings, or None. Special cases, such as the wildcard (<code>*</code>) and JSON-encoded string or list, are also handled appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str | list[str] | None</code> <p>A string, list of strings, or None representing CORS origins. It can include inputs such as a JSON-formatted list or a wildcard (<code>*</code>).</p> required <p>Returns:</p> Type Description <code>str</code> <p>A tuple of strings representing standardized CORS origins. Each origin string is</p> <code>...</code> <p>stripped of surrounding whitespace and any trailing forward slash.</p> Source code in <code>src/nexor/utils.py</code> <pre><code>def parse_cors_origins(value: str | list[str] | None) -&gt; tuple[str, ...]:\n    \"\"\"\n    Parses and normalizes CORS origins from a string, list, or None into a tuple of strings.\n\n    This function handles various input formats to ensure they are correctly parsed into a\n    standardized tuple of origin strings usable for configuration. The input can be a string,\n    list of strings, or None. Special cases, such as the wildcard (`*`) and JSON-encoded\n    string or list, are also handled appropriately.\n\n    Args:\n        value: A string, list of strings, or None representing CORS origins. It can include\n            inputs such as a JSON-formatted list or a wildcard (`*`).\n\n    Returns:\n        A tuple of strings representing standardized CORS origins. Each origin string is\n        stripped of surrounding whitespace and any trailing forward slash.\n    \"\"\"\n    if not value:\n        return ()\n    if value in ('*', '\"*\"'):\n        return ('*',)\n    if isinstance(value, str):\n        try:\n            parsed = json.loads(value)\n            if isinstance(parsed, str):\n                return (parsed.strip().rstrip('/'),)\n            if isinstance(parsed, (list, tuple)):\n                return tuple(o.strip().rstrip('/') for o in parsed)\n        except json.JSONDecodeError:\n            return tuple(o.strip().rstrip('/') for o in value.split(',') if o.strip())\n    if isinstance(value, (list, tuple)):\n        return tuple(str(o).strip().rstrip('/') for o in value)\n    return (str(value).strip().rstrip('/'),)\n</code></pre>"}]}